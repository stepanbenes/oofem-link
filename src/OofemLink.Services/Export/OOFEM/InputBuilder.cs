using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Reflection;
using System.Globalization;
using System.Diagnostics;

namespace OofemLink.Services.Export.OOFEM
{
	class InputBuilder
	{
		#region Fields, constructor

		readonly List<HeaderRecord> headerRecords;
		readonly List<NodeRecord> nodeRecords;
		readonly List<ElementRecord> elementRecords;
		readonly List<CrossSectionRecord> crossSectionRecords;
		readonly List<MaterialRecord> materialRecords;
		readonly List<BoundaryConditionRecord> boundaryConditionRecords;
		readonly List<TimeFunctionRecord> timeFunctionRecords;
		readonly List<SetRecord> setRecords;

		public InputBuilder()
		{
			headerRecords = new List<HeaderRecord>();
			nodeRecords = new List<NodeRecord>();
			elementRecords = new List<ElementRecord>();
			crossSectionRecords = new List<CrossSectionRecord>();
			materialRecords = new List<MaterialRecord>();
			boundaryConditionRecords = new List<BoundaryConditionRecord>();
			timeFunctionRecords = new List<TimeFunctionRecord>();
			setRecords = new List<SetRecord>();
		}

		#endregion

		#region Public methods

		public void WriteToFile(string fileFullPath)
		{
			using (var stream = new FileStream(fileFullPath, FileMode.Create, FileAccess.Write, FileShare.None))
			using (var streamWriter = new StreamWriter(stream))
			{
				// Write header comment
				streamWriter.WriteLine($"# OOFEM input file. Generated by {getProgramDescription()} on machine {Environment.MachineName}");
				foreach (var record in headerRecords)
					streamWriter.WriteLine(record.ToString());

				// calculate and print numbers of records
				streamWriter.WriteLine(buildRecordCountsString());

				streamWriter.WriteLine($"# NODES");
				foreach (var record in nodeRecords)
					streamWriter.WriteLine(record.ToString());

				streamWriter.WriteLine($"# ELEMENTS");
				foreach (var record in elementRecords)
					streamWriter.WriteLine(record.ToString());

				streamWriter.WriteLine($"# CROSS-SECTIONS");
				foreach (var record in crossSectionRecords)
					streamWriter.WriteLine(record.ToString());

				streamWriter.WriteLine($"# MATERIALS");
				foreach (var record in materialRecords)
					streamWriter.WriteLine(record.ToString());

				streamWriter.WriteLine($"# BOUNDARY CONDITIONS");
				foreach (var record in boundaryConditionRecords)
					streamWriter.WriteLine(record.ToString());

				streamWriter.WriteLine($"# TIME FUNCTIONS");
				foreach (var record in timeFunctionRecords)
					streamWriter.WriteLine(record.ToString());

				streamWriter.WriteLine($"# SETS");
				foreach (var record in setRecords)
					streamWriter.WriteLine(record.ToString());
			}
		}

		public void AddHeaderRecord(HeaderRecord record)
		{
			headerRecords.Add(record);
		}

		public void AddNodeRecord(NodeRecord record)
		{
			nodeRecords.Add(record);
		}

		public void AddElementRecord(ElementRecord record)
		{
			elementRecords.Add(record);
		}

		public void AddCrossSectionRecord(CrossSectionRecord record)
		{
			crossSectionRecords.Add(record);
		}

		public void AddMaterialRecord(MaterialRecord record)
		{
			materialRecords.Add(record);
		}

		public void AddBoundaryConditionRecord(BoundaryConditionRecord record)
		{
			boundaryConditionRecords.Add(record);
		}

		public void AddTimeFunctionRecord(TimeFunctionRecord record)
		{
			timeFunctionRecords.Add(record);
		}

		public void AddSetRecord(SetRecord record)
		{
			setRecords.Add(record);
		}

		#endregion

		#region Private methods

		private static string getProgramDescription()
		{
			var assembly = Assembly.GetEntryAssembly();
			var assemblyTitleAttribute = assembly.GetCustomAttribute<AssemblyTitleAttribute>();
			var assemblyFileVersionAttribute = assembly.GetCustomAttribute<AssemblyFileVersionAttribute>();
			return $"{assemblyTitleAttribute.Title} version {assemblyFileVersionAttribute.Version}";
		}

		private string buildRecordCountsString()
		{
			int dofManagerCount = nodeRecords.Count;
			int elementCount = elementRecords.Count;
			int crossSectionCount = crossSectionRecords.Count;
			int materialCount = materialRecords.Count;
			int boundaryConditionCount = boundaryConditionRecords.Count;
			int initialConditionCount = 0; /*no initial conditions for time-independent analysis (statics)*/
			int timeFunctionCount = timeFunctionRecords.Count;
			int setCount = setRecords.Count;

			return $"{Keyword.ndofman} {dofManagerCount} {Keyword.nelem} {elementCount} {Keyword.ncrosssect} {crossSectionCount} {Keyword.nmat} {materialCount} {Keyword.nbc} {boundaryConditionCount} {Keyword.nic} {initialConditionCount} {Keyword.nltf} {timeFunctionCount} {Keyword.nset} {setCount}";
		}

		#endregion
	}
}
